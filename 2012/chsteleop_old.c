#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S1,     ,                    sensorI2CMuxController)
#pragma config(Sensor, S2,     sonarL,              sensorSONAR)
#pragma config(Sensor, S3,     sonarR,              sensorSONAR)
#pragma config(Sensor, S4,     touch,               sensorTouch)
#pragma config(Motor,  mtr_S1_C1_1,     LeftSideMotors, tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     RightSideMotors, tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     conveyor1,     tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     stacker,       tmotorNormal, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    SERVOGATE,            tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//*****************************************************************
//
//
// started 10/24/10
//*****************************************************************

#include "constants.c"
#include "driveMover.c"
#include "JoystickDriver.c"
// there's a joystick attached
//////////////////////////////
//joystick variables
//we convert to this format to make programming easier and more natural

int drivejy1,drivejy2,driveButtons,driveTopHat;
int  armjy1,armjy2,armTopHat,armButtons;
bool armButton1,armButton2,armButton3,armButton4,armButton5;
bool armButton6,armButton7,armButton8,armButton9,armButton10;
bool driveButton1,driveButton2,driveButton3,driveButton4,driveButton5;
bool driveButton6,driveButton7,driveButton8,driveButton9,driveButton10;

bool drivingreversed=false;
bool B_gateOpen;
void getJoyValues(){
  getJoystickSettings(joystick);

  //DRIVING JOYSTICK VALUES
 drivejy1=joystick.joy1_y1;
 drivejy2=joystick.joy1_y2;
 driveButtons=joystick.joy1_Buttons;
 driveTopHat =joystick.joy1_TopHat;
 driveTopHat=-1;

 driveButton1=((driveButtons&1)>0);driveButton2=((driveButtons&2)>0);driveButton3=((driveButtons&4)>0);driveButton4=((driveButtons&8)>0);driveButton5=((driveButtons&16)>0);
 driveButton6=((driveButtons&32)>0);driveButton7=((driveButtons&64)>0);driveButton8=((driveButtons&128)>0);driveButton9=((driveButtons&256)>0);driveButton10=((driveButtons&512)>0);

 //ARM JOYSTICK VALUES
 armTopHat =joystick.joy2_TopHat;
 armButtons=joystick.joy2_Buttons;
 armjy1= joystick.joy2_y1;
 armjy2= joystick.joy2_y2;

 armButton1=((armButtons&1)>0);armButton2=((armButtons&2)>0);armButton3=((armButtons&4)>0);armButton4=((armButtons&8)>0);armButton5=((armButtons&16)>0);
 armButton6=((armButtons&32)>0);armButton7=((armButtons&64)>0);armButton8=((armButtons&128)>0);armButton9=((armButtons&256)>0);armButton10=((armButtons&512)>0);
}

//////////////////////////////////
void initializeRobot(){
  servoChangeRate[SERVOGATE]   = 10;
  //servoChangeRate[servoFlip] = 10;
  //servoChangeRate[hopControl] = 20;
  //servo[servoFlip] = SERVOARMUP;
  servo[SERVOGATE]  =  SERVOGATECLOSE;
  //servo[hopControl] = HOPCONTROLCLOSED;
}

task DriveUpdate(){
  while(true){
    getJoyValues();
    if(B_gateOpen) servo[SERVOGATE]=SERVOGATEOPEN;
   	if(abs(drivejy1)<10) drivejy1=0;
    if(abs(drivejy2)<10) drivejy2=0;
	  //standard driving
    if(drivingreversed) standardDrive(-(100*drivejy2)/127,-(100*drivejy1)/127);
    else standardDrive((100*drivejy1)/127,(100*drivejy2)/127);
  }
}

task main() {
  bool conveyoron=false;

  initializeRobot();

  waitForStart();   // wait for start of tele-op phase

  StartTask(DriveUpdate,0);

  servo[SERVOGATE]  =  SERVOGATECLOSE;    B_gateOpen=false;

  ClearTimer(T1); //we use timer T1 for program time

  while(true){

	  getJoyValues();

	  if(B_gateOpen) servo[SERVOGATE]=SERVOGATEOPEN;

    //////////////////////////////////
    //arm control button processing
	  if(driveButton10) {
	    drivingreversed=!drivingreversed;
	    wait1Msec(200);
	  }
	  if(driveButton6){
	    if(servo[SERVOGATE]==SERVOGATECLOSE){
	      servo[SERVOGATE] = SERVOGATEOPEN;
	      B_gateOpen=true;
	      wait1Msec(200);
	     }
	  else {
	    servo[SERVOGATE] = SERVOGATECLOSE;
	    B_gateOpen=false;
	    wait1Msec(300);
	    }
	   }
	  if(driveButton7 || armButton7){
	    if(conveyoron){
	      motor[conveyor1]=0;
	      wait1Msec(300);
        conveyoron=false;
	     }
	  else {
	    motor(conveyor1) = 100;
	    wait1Msec(300);
	    conveyoron=true;
	    }
	  }
	  if(driveButton5 || armButton5){
	    motor[conveyor1]=-100;
	    wait1Msec(300);
	    motor[conveyor1]=0;
	    conveyoron=false;
	  }
	  /*if(armButton1){
	    servo[servoFlip]=SERVOARMDOWN;
	    wait1Msec(500);
	    driveNudge(-50, -50, 500);
	    servo[servoFlip]=SERVOARMUP;
	  }
	  if(armButton4){
	    servo[servoFlip]=SERVOARMUP;
	    wait1Msec(50);
	  }
    if(armButton2){
      servo[servoFlip]=SERVOARMDOWN;
      wait1Msec(50);
    }
    if(armTopHat>=0){
      if(armTopHat==0){
        servo[hopControl]=HOPCONTROLUP;
        wait1Msec(50);
      }
      if(armTopHat==4){
        servo[hopControl]=HOPCONTROLDOWN;
        wait1Msec(50);
      }
      if(armTopHat==2){
        for(int i=0; i<=2; i++){
          servo[hopControl]=HOPCONTROLP1;
          wait1Msec(300);
          servo[hopControl]=HOPCONTROLP2;
          wait1Msec(300);
        }
        servo[hopControl]=HOPCONTROLDOWN;
        wait1Msec(50);
      }
      if(armTopHat==6){
        servo[hopControl]=HOPCONTROLCLOSED;
        wait1Msec(50);
      }
    }*/


    //////////////////////////
    //DRIVING
    //////////////////////////

    //Nudging, at most 1 every 1/10 second
  	if(time10(T4)<0) ClearTimer(T4); //keep timer positive
	  if(time10(T4)>10){
		  if(driveTopHat>=0){
			if(driveTopHat==0) driveNudge( 50, 50,60); //forward
			if(driveTopHat==1) driveNudge(  0, 50,60);
			if(driveTopHat==2) driveNudge( -50,50,60); //right
			if(driveTopHat==3) driveNudge( -50, 0,60);
			if(driveTopHat==4) driveNudge(-50,-50,60); //back
			if(driveTopHat==5) driveNudge( 0, -50,60);
			if(driveTopHat==6) driveNudge( 50,-50,60); //left
			if(driveTopHat==7) driveNudge( 50,  0,60);
			ClearTimer(T4); //so delay at least 100 Msec before next nudge
		  }
	  }
    /*if(abs(armjy1)<18) armjy1=0;
      motor[flipper]=((100*armjy1)/700);*/
	  if(abs(drivejy1)<10) drivejy1=0;
      if(abs(drivejy2)<10) drivejy2=0;
	  //standard driving
    if(drivingreversed) standardDrive(-(100*drivejy2)/127,-(100*drivejy1)/127);
    else standardDrive((100*drivejy1)/127,(100*drivejy2)/127);

  }
////////// end of infinite loop

}
