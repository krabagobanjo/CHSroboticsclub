#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  HTMotor)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  motorA,          flipper,       tmotorNormal, openLoop, encoder)
#pragma config(Motor,  motorB,          catchR,        tmotorNormal, openLoop, encoder)
#pragma config(Motor,  motorC,          catchL,        tmotorNormal, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     LeftSideMotors, tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     RightSideMotors, tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     conveyor1,     tmotorNormal, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     stacker,       tmotorNormal, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C4_1,     spoolL,        tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     spoolR,        tmotorNormal, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    servoCrateL,          tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    servoCrateR,          tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    servoGripL,           tServoStandard)
#pragma config(Servo,  srvo_S1_C3_4,    servoGripR,           tServoStandard)
#pragma config(Servo,  srvo_S1_C3_5,    hookL,                tServoStandard)
#pragma config(Servo,  srvo_S1_C3_6,    hookR,                tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//*****************************************************************
//
//
// started 10/24/10
//*****************************************************************

#include "constants.c"
#include "driveMover.c"
#include "JoystickDriver.c"
// there's a joystick attached
//////////////////////////////
//joystick variables
//we convert to this format to make programming easier and more natural

int drivejy1,drivejy2,driveButtons,driveTopHat;
int  armjy1,armjy2,armTopHat,armButtons;
int  armjx2;
bool armButton1,armButton2,armButton3,armButton4,armButton5;
bool armButton6,armButton7,armButton8,armButton9,armButton10;
bool driveButton1,driveButton2,driveButton3,driveButton4,driveButton5;
bool driveButton6,driveButton7,driveButton8,driveButton9,driveButton10;

void getJoyValues(){
  getJoystickSettings(joystick);

  //DRIVING JOYSTICK VALUES
 drivejy1=joystick.joy1_y1;
 drivejy2=joystick.joy1_y2;
 driveButtons=joystick.joy1_Buttons;
 driveTopHat =joystick.joy1_TopHat;

 driveButton1=((driveButtons&1)>0);driveButton2=((driveButtons&2)>0);driveButton3=((driveButtons&4)>0);driveButton4=((driveButtons&8)>0);driveButton5=((driveButtons&16)>0);
 driveButton6=((driveButtons&32)>0);driveButton7=((driveButtons&64)>0);driveButton8=((driveButtons&128)>0);driveButton9=((driveButtons&256)>0);driveButton10=((driveButtons&512)>0);

 //ARM JOYSTICK VALUES
 armTopHat =joystick.joy2_TopHat;
 armButtons=joystick.joy2_Buttons;
 armjy1= joystick.joy2_y1;
 armjy2= joystick.joy2_y2;
 armjx2= joystick.joy2_x2;

 armButton1=((armButtons&1)>0);armButton2=((armButtons&2)>0);armButton3=((armButtons&4)>0);armButton4=((armButtons&8)>0);armButton5=((armButtons&16)>0);
 armButton6=((armButtons&32)>0);armButton7=((armButtons&64)>0);armButton8=((armButtons&128)>0);armButton9=((armButtons&256)>0);armButton10=((armButtons&512)>0);
}


bool liftUp=false;
//////////////////////////////////
//DEFINITION OF ARMWAIT
void armwait1Msec(int duration){
  ClearTimer(T3);

  while(true){
    getJoystickSettings(joystick);
    if(!liftUp) liftReleaseMaintain(0,0);

    //DRIVING JOYSTICK VALUES
    drivejy1=joystick.joy1_y1;
    drivejy2=joystick.joy1_y2;

    //if(time1[T3]>=duration) break;

    if(abs(drivejy1)<10) drivejy1=0;
    if(abs(drivejy2)<10) drivejy2=0;

    standardDrive((100*drivejy2)/127,(100*drivejy1)/127 );
    if(time1[T3]>=duration) break;
  }
  return;
}

void initializeRobot(){
  //servoChangeRate[SERVOGATE]   = 10;
  servoChangeRate[servoCrateL]   = 20;
  servoChangeRate[servoCrateR]   = 20;
  servoChangeRate[hookL]   = 20;
  servoChangeRate[hookR]   = 20;
  //servoChangeRate[servoFlip] = 10;
  //servoChangeRate[hopControl] = 20;
  //servo[servoFlip] = SERVOARMUP;
  //servo[SERVOGATE]  =  SERVOGATEOPEN;
  servo[servoCrateL]  =  CRATELUP;
  servo[servoCrateR]  =  CRATERUP;
  servo[servoGripL]  =  GRIPLTHIN;
  servo[servoGripR]  =  GRIPRTHIN;
  servo[hookL]  =  hookfoldL;
  servo[hookR]  =  hookfoldR;
  //servo[hopControl] = HOPCONTROLCLOSED;
  nMotorEncoder[stacker]=0;
  motor[catchL]=-40;
  motor[catchR]=-40;
  wait1Msec(250);
  nMotorEncoder[catchL]=0;
  nMotorEncoder[catchR]=0;
  motor[catchL]=0;
  motor[catchR]=0;
  nMotorEncoder[flipper]=0;
  motor[flipper]=0;
}


task main() {
  bool conveyoron=false;

  initializeRobot();

  int pressed=0;
  bool pLup=false;
  bool pLdown=false;
  bool pRup=false;
  bool pRdown=false;
  bool hLback=false;
  bool hRback=false;
  bool hLinsert=false;
  bool hRinsert=false;
  bool spoolLlaunched=false;
  bool spoolRlaunched=false;
  bool flipperDown=true;

  waitForStart();   // wait for start of tele-op phase

  //we use timer T3 for arm wait
  ClearTimer(T1);
  ClearTimer(T2);
  ClearTimer(T4);


int readB,readC,sumB=0,sumC=0;

  servo[hookL]=hookbL;
  servo[hookR]=hookbR;

  while(true){

	  getJoyValues();
	  //maintainence of lift release
	  if(!liftUp) liftReleaseMaintain(0,0);


    readB=nMotorEncoder[catchR];
    readC=nMotorEncoder[catchL];
    sumB+=readB;
    sumC+=readC;





  nxtDisplayCenteredBigTextLine(1, "%d %d",readB,nMotorEncoder[flipper]);
  nxtDisplayCenteredBigTextLine(3, "%d %d",sumB,sumC);
    //////////////////////////////////
    //conveyor button processing
	  if(driveButton2){
	    if(conveyoron){
	      motor[conveyor1]=0;
	      armwait1Msec(300);
        conveyoron=false;
	     }
	    else {
	      motor(conveyor1) = 100;
	      armwait1Msec(300);
	      conveyoron=true;
	    }
	  }
	  if(driveButton4){
	    motor[conveyor1]=-100;
	    armwait1Msec(300);
	    motor[conveyor1]=0;
	    conveyoron=false;
	  }

	  if(driveTopHat>=0){
	    if(driveTopHat==4){
	      flipperDown=true;
      }

      if(driveTopHat==0){
        flipperDown=false;
	    }

    }

    if(flipperDown) {
      if(nMotorEncoder[flipper]<4) motor[flipper]=100;
      else motor[flipper]=0;
    }
    if(!flipperDown) {
      if(nMotorEncoder[flipper]>-110) motor[flipper]=-100;
      else {
        if(nMotorEncoder[flipper]<-115) motor[flipper]=50;
        else motor[flipper]=0;
      }
    }

	  //////////////////////////////
	  //Spool button controls
	  if(!driveButton8 && !driveButton6) motor[spoolR]=0;
	  if(driveButton8 && !driveButton6 && liftUp && (hRinsert || spoolRlaunched)) {
	    motor[spoolR]=100;
	    if(!spoolRlaunched) {
	      servo[hookR]=hookRpushin;
	      ClearTimer(T2);
	    }
	    else{
	      if(time1[T2]>3000) servo[hookR]=hookinsertR;
	    }
	    spoolRlaunched=true;
	  }
	  if(driveButton6 && !driveButton8 && liftUp && (hRinsert || spoolRlaunched)) {
	    motor[spoolR]=-50;
	    spoolRlaunched=true;
	  }
	  if(!driveButton7 && !driveButton5) motor[spoolL]=0;
	  if(driveButton7 && !driveButton5 && liftUp && (hLinsert || spoolLlaunched)) {
	    motor[spoolL]=100;
	    if(!spoolLlaunched) {
	      servo[hookL]=hookLpushin;
	      ClearTimer(T2);
	    }
	    else{
	      if(time1[T2]>3000) servo[hookL]=hookinsertL;
	    }
	    spoolLlaunched=true;
	  }
	  if(driveButton5 && !driveButton7 && liftUp && (hLinsert || spoolLlaunched)) {
	    motor[spoolL]=-50;
	    spoolLlaunched=true;
	  }

	  //////////////////////////////
	  //arm crate servos button controls
	  if (armButton4){
	    servo[servoCrateL]=CRATELUP;
	    servo[servoCrateR]=CRATERUP;
	    armwait1Msec(100);
	  }
	  if (armButton2){
	    servo[servoCrateL]=CRATELDOWN;
	    servo[servoCrateR]=CRATERDOWN;
	    armwait1Msec(100);
	  }
	  if (armButton1){
	    servo[servoCrateL]=CRATELIN;
	    servo[servoCrateR]=CRATERIN;
	    armwait1Msec(100);
	  }
    if (armButton3){
      servo[servoCrateL]=CRATELOUT;
      servo[servoCrateR]=CRATEROUT;
	    armwait1Msec(100);
	  }
	  if(abs(armjx2)>18) {
	    int scL=servoValue[servoCrateL];
	    int scR=servoValue[servoCrateR];
	    if (armjx2<0) {
	      servo[servoCrateL]=scL+3;
	      servo[servoCrateR]=scR-3;
	    }
	    if (armjx2>0) {
	      servo[servoCrateL]=scL-3;
	      servo[servoCrateR]=scR+3;
	    }
	  }

	  ///////////////////////////
	  //crate hook controls
	  //////////////////////////
    if(armButton9){
      if(!hLback){
        servo[hookL]=hookbackL;
        hLback=true;
        hLinsert=false;
      }
      else{
        servo[hookL]=hookinsertL;
        hLback=false;
        hLinsert=true;
      }
      armwait1Msec(300);
    }
    if(armButton10){
      if(!hRback){
        servo[hookR]=hookbackR;
        hRback=true;
        hRinsert=false;
      }
      else{
        servo[hookR]=hookinsertR;
        hRback=false;
        hRinsert=true;
      }
      armwait1Msec(300);
    }
    ///////////////////
    //gripper with top hat
    if(armTopHat>=0){
      if(armTopHat==0){ //up
        servo[servoGripL]=GRIPLOPEN;
	      servo[servoGripR]=GRIPROPEN;
	      //wait1Msec(50);
      }
      if(armTopHat==4){ //down
	      servo[servoGripL]=GRIPLTHIN;
	      servo[servoGripR]=GRIPRTHIN;
	      //wait1Msec(50);
     }
      if(armTopHat==2){ //right
      }
      if(armTopHat==6){ //left
        nMotorEncoder[stacker]=0;
      }
    }//end of tophat

    //////////////////////////////
    //Lift release
    if(armButton5 && armButton6)
    {
      if(!hLinsert){
        servo[hookL]=hookfL;
        armwait1Msec(300);
      }
      if(!hRinsert){
        servo[hookR]=hookfR;
        armwait1Msec(300);
      }
      ClearTimer(T4);
      while(nMotorEncoder[motorB]<70 && nMotorEncoder[motorC]<70 && time1[T4]<1000)
      {
        motor[motorB]=100;
        motor[motorC]=100;
        //do not use armwait (resets )
      }
      motor[motorB]=0;
      motor[motorC]=0;

      liftUp=true;
    }

    //////////////////////////////
    //Lift gate return
    if(armButton7 && armButton8)
    {
      if(nMotorEncoder[motorB]>0 && nMotorEncoder[motorC]>0)
      {
        motor[motorB]=-100;
        motor[motorC]=-100;
        wait1Msec(100);//do not use armwait (resets )
      }
      motor[motorB]=0;
      motor[motorC]=0;
    }




    //////////////////////////
    //DRIVING
    //////////////////////////

    //Nudging, at most 1 every 1/10 second
  	if(time10(T4)<0) ClearTimer(T4); //keep timer positive
    if(abs(armjy1)<18) armjy1=0;
    if(nMotorEncoder[stacker]<armlimitdown && armjy1<0 && pressed==0) armjy1=0;
    if(nMotorEncoder[stacker]>armlimitup && armjy1>0 && pressed==0) armjy1=0;
    motor[stacker]=((100*armjy1)/128);
	  if(abs(drivejy1)<10) drivejy1=0;
    if(abs(drivejy2)<10) drivejy2=0;
	  //standard driving
    /*if(drivingreversed) standardDrive(-(100*drivejy2)/127,-(100*drivejy1)/127);
    else standardDrive((100*drivejy1)/127,(100*drivejy2)/127);*/
    standardDrive((100*drivejy1)/127,(100*drivejy2)/127);
  }
////////// end of infinite loop

}
